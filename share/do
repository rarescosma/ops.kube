#!/usr/bin/env bash

set -e

DOT=$(cd -P "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)
export DOT
export TPL=$DOT/templates

if [ ! -z "$1" ] && [ -z "$CLUSTER" ]; then
  export CLUSTER="$1"
  shift
fi

# shellcheck source=lib/log.sh
export VM_HOST=$(hostname -s)
source "$DOT/lib/log.sh"
source "$DOT/$CLUSTER-env.sh"
source "$DOT/$CLUSTER-cluster.sh" || true
# shellcheck source=lib/utils.sh
source "$DOT/lib/utils.sh"
# shellcheck source=lib/cluster.sh
source "$DOT/lib/cluster.sh"
# shellcheck source=/dev/null
if test -f "${DOT}/lib/host.${KUBE_HOST}.sh"; then
  source "${DOT}/lib/host.${KUBE_HOST}.sh"
fi
# shellcheck source=lib/network.sh
source "$DOT/lib/network.sh"
# shellcheck source=lib/orchestrate.sh
source "$DOT/lib/orchestrate.sh"
# shellcheck source=lib/prepare.sh
source "$DOT/lib/prepare.sh"
# shellcheck source=lib/provision.sh
source "$DOT/lib/provision.sh"
# shellcheck source=/dev/null
source "${DOT}/lib/vm.${VM_ENGINE}.sh"

start() {
  dumpstack "$*"
  utils::function_exists "host::prepare" && host::prepare

  prepare
  utils::function_exists "vm::prepare" && vm::prepare
  orchestrate

  network::cycle
}

stop() {
  dumpstack "$*"
  utils::function_exists "host::stop" && host::stop

  cluster::stop
  network::stop
}

clean() {
  stop

  # Clean prepare stage
  rm -rf "${DOT:?}/bin/*"
  rm -rf "$DOT/etc/tls/$CLUSTER"

  cluster::clean
  utils::function_exists "vm::clean" && vm::clean
}

orchestrate() {
  orchestrate::master 0

  for x in $(seq 0 $((VM_NUM_WORKERS-1))); do
    orchestrate::worker "$x" &
  done
  wait
}

"$@"
